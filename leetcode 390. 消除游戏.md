# [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。

 

示例 1：

输入：n = 9
输出：6
解释：
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]
示例 2：

输入：n = 1
输出：1


提示：

1 <= n <= 10^9

## 个人题解

看到这道题，第一反应应该是模拟，但是一看n的范围，显然是不能实现的。

那么肯定是需要找规律了，这题每次从右往左，从左往右，都要删除一半的人，让我想起了约瑟夫问题，这题也可以借鉴约瑟夫问题的思路。

以 n=9 的情况为例：

第一轮 9 人 从左往右删除

第二轮 4 人 从右往左删除

第三轮 2 人 从左往右删除

第四轮 1 人。

使用约瑟夫问题的倒推方法模拟：

从第四轮开始，余下一人就是我们要求的target，以0表示最后余下的一人，X表示本轮删除的人，x表示其余删除的人

第四轮 1人 

​	队列情况为 0

从第四轮推第三轮，是从左往右删除的，所以第四轮的每个人左侧都应该有一个人，且本轮总人数为2人

​	队列情况为 X 0

从第三轮推第二轮，为从右往左删除人，所有每个人右侧都应该有一个人，且本轮总人数为4人

​	队列情况为 x X O X

从第二轮推第一轮，为从左往右删除人，所以每个人左侧应该有一个人，且本轮总人数为9人，多出一人，显然此人在队列最右侧

​	队伍情况为 X x X x X O X x X

此时我们就知道了O为队伍的第6人。

通过以上模拟发现，每次删除人数，与本轮人数以及删除方向有关，而我们最终要求的是最后生还者，所以我们只需要知道，在第一轮开始时，最后生还者的左侧有多少人

最后一轮，仅有生还者1人

倒数第二轮，如果本轮为从左往右删除，则每个人左侧必有1人，那么生还者前面就有1人；如果本轮为从右往左删除，每人右侧必须有一个人，但如果本轮人数为奇数，那么除了每人右侧的人，队伍最左侧还应加上一人。

...

第m轮，m+1人时生还者左侧有s人。如果本轮为从左往右删除，则每个人左侧必有1人，那么生还者前面就有2*s+1人，其中2*s为生还者左侧的人每人左侧多一人，1为生还者本人左侧还需要加一人；如果本轮为从右往左删除，每人右侧必须有一个人，即为2*s，但如果本轮人数为奇数，那么除了每人右侧的人，队伍最左侧还应加上一人，即为2*s+1。

直到求出第一轮即可知道生还者的index。

## 代码如下

```c++
class Solution {
public:
    int search(int n,bool flag) // flag=true 向右删除，flag=false向左删除
    {
        if (n==1) return 0;
        int s = search(n/2,!flag);
        if (flag) return 2*s+1;
        else if (n%2==0) return 2*s;
             else return 2*s+1;

    }
    int lastRemaining(int n) {
        return search(n,true)+1;
    }
};
```

