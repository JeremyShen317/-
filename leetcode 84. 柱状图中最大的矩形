84. 柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。


输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10

示例 2：

输入： heights = [2,4]
输出： 4
 

提示：

1 <= heights.length <=105
0 <= heights[i] <= 104

题解：
这一题是典型的单调栈思路，用栈存储一个单调上升的序列，遇到一个比栈顶元素低的柱子，则进行矩形面积计算。
以例1为例，[2,1,5,6,2,3]
  2入栈 ---  [0] 栈中放入index用于计算宽度
  遇到1，小于栈顶元素，出栈直到栈空或者栈顶元素小于1同时计算面积，2出栈，计算面积为1*2=2，栈空了，1入栈 --- [1]
  5入栈 --- [1,2]
  6入栈 --- [1,2,3]
  遇到2,6>2，故6出栈计算面积6*1=6;5>2，故出栈，5*2=10；1小于2,2入栈 --- [1,4]
  3入栈 [1,4,5]
  为了方便，最后高度为0的元素入栈，3>0，1*3=3；2>0,2*2=4；1>0,3*1=3;
  到此，过程中最大的面积为10.
其中计算面积为本题关键，高度显然是出栈元素的高度，宽度又该如何确定？
右边界必定是当前要入栈元素下标减一，左边界呢？一开始我以当前出栈元素下标为左边界，可考虑到如下例子
例 [0,2,1,2]
  0入栈 --- [0]
  2入栈 --- [0,1]
  1,1<2 故2*1=2,2出栈，1入栈 --- [0,2]
  2入栈 --- [0,2,3]
  最后入0,2*1=2；1*2=2，至此计算最大值为2.可实际是3.
问题在哪儿呢，显然最后0入栈以后，计算面积应为2*1=2； 1*3=3！
这个3是哪里来的呢，右边界显然是3，左边界应该为1，而不是2.
至此，答案很明显了，对于1高度柱子，其左边界应为前面比他低的柱子坐标+1

代码如下：
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        stack<int> stk;
        int res=0;
        for (int i=0; i<heights.size(); ++i)
        {
            while (!stk.empty() && heights[stk.top()]>heights[i])
            {
                int h=heights[stk.top()];
                stk.pop();
                int left=stk.top()+1;
                int right=i-1;
                int area=(right-left+1)*h;
                res=max(area,res);
            }
            stk.push(i);
        }
        return res;
    }
};

  
